<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Laravel SmartCache ‚Äî Intelligent caching with automatic compression, cost-aware eviction, and full Laravel API compatibility. Drop-in replacement for Cache facade.">
    <meta name="keywords" content="Laravel, caching, PHP, performance, SWR, compression, enterprise, cost-aware, Redis, optimization, cache stampede, PSR-16">
    <meta name="author" content="Ismael Azaran">
    <title>Laravel SmartCache Documentation</title>
    
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #2c3e50;
            background: #f8f9fa;
            -webkit-font-smoothing: antialiased;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 1.5em;
            font-weight: 600;
        }

        .nav-links {
            display: flex;
            gap: 20px;
        }

        .nav-links a {
            color: white;
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 20px;
            transition: background 0.3s ease;
        }

        .nav-links a:hover {
            background: rgba(255,255,255,0.2);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        .main-content {
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: 30px;
            padding: 30px 0;
            min-height: calc(100vh - 80px);
        }

        .sidebar {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            height: fit-content;
            position: sticky;
            top: 20px;
        }

        .sidebar h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .sidebar ul {
            list-style: none;
        }

        .sidebar li {
            margin-bottom: 8px;
        }

        .sidebar a {
            color: #2c3e50;
            text-decoration: none;
            padding: 8px 12px;
            border-radius: 6px;
            display: block;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }

        .sidebar a:hover,
        .sidebar a.active {
            background: #667eea;
            color: white;
        }

        .content {
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .tab-container {
            display: none;
        }

        .tab-container.active {
            display: block;
        }

        .tab-nav {
            display: flex;
            border-bottom: 2px solid #ecf0f1;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .tab-nav button {
            background: none;
            border: none;
            padding: 15px 20px;
            cursor: pointer;
            font-size: 1em;
            color: #7f8c8d;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .tab-nav button:hover {
            color: #667eea;
        }

        .tab-nav button.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 2.2em;
            font-weight: 300;
        }

        h2 {
            color: #2c3e50;
            margin: 30px 0 15px 0;
            font-size: 1.6em;
            font-weight: 400;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 10px;
        }

        h3 {
            color: #34495e;
            margin: 25px 0 10px 0;
            font-size: 1.3em;
        }

        .code {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Monaco', 'Consolas', 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.5;
        }
        
        /* Override Prism.js styles for better integration */
        pre[class*="language-"] {
            background: #2c3e50 !important;
            border-radius: 8px !important;
            margin: 15px 0 !important;
            padding: 20px !important;
        }
        
        code[class*="language-"] {
            font-family: 'Monaco', 'Consolas', 'Courier New', monospace !important;
            font-size: 0.9em !important;
            line-height: 1.5 !important;
        }

        .code-inline {
            background: #f1f2f6;
            color: #e74c3c;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Monaco', 'Consolas', 'Courier New', monospace;
            font-size: 0.9em;
        }

        .alert {
            padding: 15px 20px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid;
        }

        .alert-info {
            background: #e3f2fd;
            border-color: #2196f3;
            color: #0d47a1;
        }

        .alert-success {
            background: #e8f5e8;
            border-color: #4caf50;
            color: #1b5e20;
        }

        .alert-warning {
            background: #fff3e0;
            border-color: #ff9800;
            color: #e65100;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .feature-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .feature-card h4 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .step {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #667eea;
        }

        .step-number {
            background: #667eea;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 15px;
        }

        .table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .table th,
        .table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ecf0f1;
        }

        .table th {
            background: #34495e;
            color: white;
            font-weight: 600;
        }

        .table tr:hover {
            background: #f8f9fa;
        }

        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: 500;
            margin: 2px;
        }

        .badge-success {
            background: #d4edda;
            color: #155724;
        }

        .badge-warning {
            background: #fff3cd;
            color: #856404;
        }

        .badge-info {
            background: #d1ecf1;
            color: #0c5460;
        }

        /* API Reference Method Styling */
        .method {
            border-left: 4px solid #667eea;
            padding-left: 20px;
            margin-bottom: 30px;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
        }

        .method-name {
            color: #667eea;
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .method-signature {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 12px;
            border-radius: 6px;
            font-family: 'Monaco', 'Consolas', monospace;
            margin: 10px 0;
            font-size: 0.9em;
            overflow-x: auto;
            white-space: nowrap;
        }

        .parameter {
            margin: 8px 0;
        }

        .parameter-name {
            font-weight: 600;
            color: #e74c3c;
        }

        .parameter-type {
            color: #3498db;
        }

        .return-type {
            color: #27ae60;
            font-weight: 600;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .sidebar {
                position: static;
                order: 1;
            }

            .content {
                order: 2;
            }

            .tab-nav {
                flex-direction: column;
            }

            .tab-nav button {
                text-align: left;
                border-bottom: 1px solid #ecf0f1;
                border-radius: 0;
            }

            .header-content {
                flex-direction: column;
                gap: 15px;
            }

            .nav-links {
                flex-wrap: wrap;
                justify-content: center;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 0 15px;
            }

            .content {
                padding: 20px;
            }

            .code {
                padding: 15px;
                font-size: 0.8em;
                overflow-x: auto;
                white-space: pre;
            }

            pre[class*="language-"] {
                overflow-x: auto !important;
                white-space: pre !important;
                word-wrap: normal !important;
            }

            .method-signature {
                overflow-x: auto !important;
                white-space: pre !important;
                word-wrap: normal !important;
                font-size: 0.8em !important;
            }

            .method {
                padding: 15px !important;
            }

            .method-name {
                font-size: 1.1em !important;
            }

            h1 {
                font-size: 1.8em;
            }

            h2 {
                font-size: 1.4em;
            }
        }
    </style>
</head>
<body>
        <div class="header">
        <div class="header-content">
            <div class="logo">Laravel SmartCache</div>
            <div class="nav-links">
                <a href="https://github.com/iazaran/smart-cache" target="_blank">üì¶ GitHub</a>
                <a href="https://packagist.org/packages/iazaran/smart-cache" target="_blank">üìã Packagist</a>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="main-content">
            <div class="sidebar">
                <h3>üìö Documentation</h3>
                <ul>
                    <li><a href="#getting-started" class="nav-link active" data-tab="getting-started">üöÄ Getting Started</a></li>
                    <li><a href="#installation" class="nav-link" data-tab="installation">üì¶ Installation</a></li>
                    <li><a href="#basic-usage" class="nav-link" data-tab="basic-usage">üíª Basic Usage</a></li>
                    <li><a href="#optimization" class="nav-link" data-tab="optimization">‚ö° Optimization</a></li>
                    <li><a href="#swr-patterns" class="nav-link" data-tab="swr-patterns">üåä SWR Patterns</a></li>
                    <li><a href="#monitoring" class="nav-link" data-tab="monitoring">üìä Monitoring</a></li>
                    <li><a href="#advanced" class="nav-link" data-tab="advanced">üîß Advanced</a></li>
                    <li><a href="#extended-features" class="nav-link" data-tab="extended-features">‚ú® Extended Features</a></li>
                    <li><a href="#api-reference" class="nav-link" data-tab="api-reference">üìö API Reference</a></li>
                    <li><a href="#testing" class="nav-link" data-tab="testing">üß™ Testing & Validation</a></li>
                    <li><a href="#migration" class="nav-link" data-tab="migration">üîÑ Migration</a></li>
                </ul>
            </div>

            <div class="content">
                <!-- Getting Started Tab -->
                <div id="getting-started" class="tab-container active">
                    <h1>Getting Started</h1>

                    <div class="alert alert-info">
                        <strong>Drop-in replacement for Laravel's Cache facade.</strong> SmartCache adds automatic compression, chunking, and cost-aware eviction to any Laravel cache driver. It implements <code>Illuminate\Contracts\Cache\Repository</code> and PSR-16 <code>SimpleCache</code> ‚Äî your existing code works unchanged.
                    </div>

                    <h2>What is SmartCache?</h2>
                    <p>SmartCache wraps Laravel's caching layer with transparent optimizations while preserving full API compatibility:</p>

                    <div class="feature-grid">
                        <div class="feature-card">
                            <h4>üì¶ Intelligent Compression</h4>
                            <p>Automatic gzip compression for large data ‚Äî significant size reduction with zero code changes.</p>
                        </div>
                        <div class="feature-card">
                            <h4>üß© Smart Chunking</h4>
                            <p>Breaks large arrays/objects into manageable pieces for better performance.</p>
                        </div>
                        <div class="feature-card">
                            <h4>üîí Atomic Locks</h4>
                            <p>Prevent cache stampede and race conditions with distributed locking.</p>
                        </div>
                        <div class="feature-card">
                            <h4>‚ö° Cache Memoization</h4>
                            <p>In-memory caching eliminates repeated lookups within a request or job.</p>
                        </div>
                        <div class="feature-card">
                            <h4>üéØ Adaptive Compression</h4>
                            <p>Auto-optimize compression levels based on data characteristics.</p>
                        </div>
                        <div class="feature-card">
                            <h4>üíæ Lazy Loading</h4>
                            <p>On-demand chunk loading keeps memory usage low for large datasets.</p>
                        </div>
                        <div class="feature-card">
                            <h4>üì° Cache Events</h4>
                            <p>Monitor and react to cache operations in real-time.</p>
                        </div>
                        <div class="feature-card">
                            <h4>üîÑ Zero Breaking Changes</h4>
                            <p>Use exactly like Laravel's Cache facade with automatic optimizations.</p>
                        </div>
                        <div class="feature-card">
                            <h4>üîê Encryption</h4>
                            <p>Automatically encrypt sensitive cached data with pattern matching.</p>
                        </div>
                        <div class="feature-card">
                            <h4>üìÅ Namespacing</h4>
                            <p>Group cache keys by namespace for better organization and bulk operations.</p>
                        </div>
                        <div class="feature-card">
                            <h4>‚è±Ô∏è TTL Jitter</h4>
                            <p>Prevent thundering herd with random TTL variation.</p>
                        </div>
                        <div class="feature-card">
                            <h4>üîå Circuit Breaker</h4>
                            <p>Protect your app from cache backend failures with automatic fallbacks.</p>
                        </div>
                    </div>

                    <h2>Quick Start</h2>
                    <div class="step">
                        <span class="step-number">1</span>
                        <strong>Install the package:</strong>
                        <div class="code">composer require iazaran/smart-cache</div>
                    </div>

                    <div class="step">
                        <span class="step-number">2</span>
                        <strong>Start using it immediately:</strong>
                        <pre><code class="language-php">use SmartCache\Facades\SmartCache;

// Works exactly like Laravel Cache
SmartCache::put('users', $users, 3600);
$users = SmartCache::get('users');</code></pre>
                    </div>

                    <div class="alert alert-success">
                        SmartCache works out-of-the-box with sensible defaults. Data is automatically compressed and optimized when beneficial.
                    </div>

                    <h2>Scales With Your Application</h2>
                    <ul>
                        <li><strong>Drop-in:</strong> Install and benefit immediately ‚Äî no code changes required</li>
                        <li><strong>Advanced patterns:</strong> SWR, stampede protection, dependency-based invalidation</li>
                        <li><strong>Observability:</strong> Real-time monitoring, cost-aware eviction, performance analysis</li>
                        <li><strong>Enterprise-ready:</strong> Circuit breakers, encryption at rest, dashboards, HTTP management APIs</li>
                    </ul>
                </div>

                <!-- Installation Tab -->
                <div id="installation" class="tab-container">
                    <h1>üì¶ Installation</h1>
                    
                    <h2>Requirements</h2>
                    <ul>
                        <li>PHP 8.1 or higher</li>
                        <li>Laravel 8.0 - 12.x (fully tested on Laravel 8, 9, 10, 11, and 12)</li>
                        <li>Any Laravel-supported cache driver (Redis, File, Database, Array, Memcached)</li>
                    </ul>

                    <div class="alert alert-success">
                        <strong>Laravel 8‚Äì12:</strong> All features are tested and supported across every major Laravel release.
                    </div>

                    <h2>Installation Steps</h2>
                    
                    <div class="step">
                        <span class="step-number">1</span>
                        <strong>Install via Composer:</strong>
                        <pre><code class="language-bash">composer require iazaran/smart-cache</code></pre>
                    </div>


                    <h2>Configuration (Optional)</h2>
                    <p>SmartCache works out-of-the-box with sensible defaults. For advanced customization:</p>

                    <div class="step">
                        <span class="step-number">1</span>
                        <strong>Publish the configuration file:</strong>
                        <pre><code class="language-bash">php artisan vendor:publish --tag=smart-cache-config</code></pre>
                    </div>

                    <div class="step">
                        <span class="step-number">2</span>
                        <strong>Configure in <span class="code-inline">config/smart-cache.php</span>:</strong>
                        <pre><code class="language-php"><?php

return [
    /*
    |--------------------------------------------------------------------------
    | Thresholds
    |--------------------------------------------------------------------------
    |
    | Configure size-based thresholds that trigger optimization strategies.
    |
    */
    'thresholds' => [
        'compression' => 1024 * 50, // 50KB - compress data larger than this
        'chunking' => 1024 * 100,   // 100KB - chunk arrays larger than this
    ],

    /*
    |--------------------------------------------------------------------------
    | Strategies
    |--------------------------------------------------------------------------
    |
    | Configure which optimization strategies are enabled and their options.
    |
    */
    'strategies' => [
        'compression' => [
            'enabled' => true,
            'level' => 6, // 0-9 (higher = better compression but slower)
        ],
        'chunking' => [
            'enabled' => true,
            'chunk_size' => 1000, // Items per chunk for arrays/collections
        ],
    ],

    /*
    |--------------------------------------------------------------------------
    | Performance Monitoring
    |--------------------------------------------------------------------------
    |
    | Enable performance monitoring to track cache hit/miss ratios,
    | optimization impact, and operation durations.
    |
    */
    'monitoring' => [
        'enabled' => true,
        'metrics_ttl' => 3600, // How long to keep metrics in cache (seconds)
        'recent_entries_limit' => 100, // Number of recent operations to track
    ],

    /*
    |--------------------------------------------------------------------------
    | Performance Warnings
    |--------------------------------------------------------------------------
    |
    | Configure thresholds for performance warnings and recommendations.
    |
    */
    'warnings' => [
        'hit_ratio_threshold' => 70, // Warn if hit ratio below this percentage
        'optimization_ratio_threshold' => 20, // Warn if optimization usage below this
        'slow_write_threshold' => 0.1, // Warn if writes slower than this (seconds)
    ],

    /*
    |--------------------------------------------------------------------------
    | Cache Drivers
    |--------------------------------------------------------------------------
    |
    | Configure which cache drivers should use which optimization strategies.
    | Set to null to use the global strategies configuration.
    |
    */
    'drivers' => [
        'redis' => null, // Use global settings
        'file' => [
            'compression' => true,
            'chunking' => true,
        ],
        'memcached' => [
            'compression' => false, // Memcached has its own compression
            'chunking' => true,
        ],
    ],

    /*
    |--------------------------------------------------------------------------
    | Fallback
    |--------------------------------------------------------------------------
    |
    | Configure fallback behavior if optimizations fail or are incompatible.
    |
    */
    'fallback' => [
        'enabled' => true,
        'log_errors' => true,
    ],
];</code></pre>
                    </div>

                    <h2>Service Provider</h2>
                    <p>SmartCache automatically registers its service provider. No additional configuration is needed for Laravel 8+.</p>
                </div>

                <!-- Basic Usage Tab -->
                <div id="basic-usage" class="tab-container">
                    <h1>üíª Basic Usage</h1>
                    
                    <h2>Familiar Laravel API</h2>
                    <p>SmartCache works exactly like Laravel's built-in Cache facade. Your existing code works unchanged:</p>

                        <pre><code class="language-php">use SmartCache\Facades\SmartCache;

// Basic caching (just like Laravel Cache)
SmartCache::put('user_data', $userData, 3600);
$userData = SmartCache::get('user_data');

// Helper function (just like cache() helper)
smart_cache(['products' => $products], 3600);
$products = smart_cache('products');

// Remember pattern (just like Cache::remember)
$users = SmartCache::remember('users', 3600, function() {
    return User::all();
});

// Check if key exists
if (SmartCache::has('users')) {
    $users = SmartCache::get('users');
}

// Forget a key
SmartCache::forget('users');

// Clear all cache
SmartCache::flush();</code></pre>

                    <h2>Using Different Cache Drivers</h2>
                    <p>Use different cache drivers while maintaining all SmartCache optimizations:</p>

                        <pre><code class="language-php">// Use Redis with all SmartCache optimizations (compression, chunking, etc.)
SmartCache::store('redis')->put('key', $value, 3600);
SmartCache::store('redis')->get('key');

// Use Memcached with optimizations
SmartCache::store('memcached')->remember('users', 3600, fn() => User::all());

// Use file cache with optimizations
SmartCache::store('file')->put('config', $config, 86400);

// Chain multiple operations on a specific store
$redisCache = SmartCache::store('redis');
$redisCache->put('users', $users, 3600);
$redisCache->put('products', $products, 3600);

// For raw access to Laravel's cache (bypasses SmartCache optimizations)
SmartCache::repository('redis')->put('key', $value, 3600);</code></pre>

                    <div class="alert alert-info">
                        <strong>Note:</strong> The <code>store()</code> method returns a SmartCache instance, so all optimization strategies (compression, chunking, encryption, etc.) continue to work. Use <code>repository()</code> if you need direct access to Laravel's cache without SmartCache optimizations.
                    </div>

                    <div class="alert alert-success">
                        <strong>Full Laravel Compatibility:</strong> SmartCache implements Laravel's <code>Illuminate\Contracts\Cache\Repository</code> interface, so it works seamlessly with any code that type-hints <code>Repository</code>. The <code>store()</code> method returns a SmartCache instance that is also a valid Repository, ensuring zero breaking changes when migrating from Laravel's Cache facade.
                    </div>

                    <h2>Automatic Optimization</h2>
                    <p>SmartCache automatically optimizes your data when beneficial:</p>

                    <pre><code class="language-php">// Large array - automatically chunked
$largeArray = range(1, 10000);
SmartCache::put('large_data', $largeArray, 3600);
// Data is automatically chunked for better performance

// Large string - automatically compressed
$largeString = str_repeat('Hello World! ', 1000);
SmartCache::put('large_text', $largeString, 3600);
// Data is automatically compressed to save space</code></pre>

                    <h2>Cache Tags</h2>
                    <p>Group related cache entries for easy management:</p>

                    <pre><code class="language-php">// Store with tags
SmartCache::tags(['users', 'profiles'])->put('user_1', $user1, 3600);
SmartCache::tags(['users', 'profiles'])->put('user_2', $user2, 3600);

// Clear all cache with specific tags
SmartCache::tags(['users'])->flush(); // Clears both user_1 and user_2

// Clear cache with multiple tags
SmartCache::tags(['users', 'profiles'])->flush();</code></pre>

                    <h2>Cache Locking</h2>
                    <p>Prevent cache stampede with atomic locks:</p>

                    <pre><code class="language-php">$lock = SmartCache::lock('expensive_operation', 10);

if ($lock->get()) {
    try {
        // Perform expensive operation
        $result = expensiveOperation();
        SmartCache::put('expensive_result', $result, 3600);
    } finally {
        $lock->release();
    }
} else {
    // Wait for the lock to be released
    $result = SmartCache::get('expensive_result');
}</code></pre>
                </div>

                <!-- Optimization Tab -->
                <div id="optimization" class="tab-container">
                    <h1>‚ö° Optimization Features</h1>
                    
                    <h2>Intelligent Compression</h2>
                    <p>SmartCache automatically compresses large data to reduce storage requirements:</p>

                    <pre><code class="language-php">// Large data automatically compressed
$largeData = [
    'products' => Product::with('images', 'reviews')->get(),
    'categories' => Category::with('children')->get(),
    'settings' => Setting::all()
];

SmartCache::put('catalog_data', $largeData, 3600);
// Automatically compressed with gzip</code></pre>

                    <h2>Smart Chunking</h2>
                    <p>Large arrays and objects are automatically chunked for better performance:</p>

                    <pre><code class="language-php">// Large array automatically chunked
$users = User::with('profile', 'posts')->get(); // 10,000+ records
SmartCache::put('all_users', $users, 3600);
// Automatically split into manageable chunks</code></pre>

                    <h2>Strategy Selection</h2>
                    <p>SmartCache automatically chooses the best optimization strategy:</p>

                    <table class="table">
                        <thead>
                            <tr>
                                <th>Data Type</th>
                                <th>Size</th>
                                <th>Strategy Applied</th>
                                <th>Benefit</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Large Arrays (5000+ items)</td>
                                <td>Any</td>
                                <td><span class="badge badge-info">Chunking</span></td>
                                <td>Better memory usage, faster access</td>
                            </tr>
                            <tr>
                                <td>Text/Strings</td>
                                <td>>50KB</td>
                                <td><span class="badge badge-success">Compression</span></td>
                                <td>Significant size reduction</td>
                            </tr>
                            <tr>
                                <td>Mixed Objects</td>
                                <td>>50KB</td>
                                <td><span class="badge badge-success">Compression</span></td>
                                <td>Optimal serialization</td>
                            </tr>
                            <tr>
                                <td>API Responses</td>
                                <td>>100KB</td>
                                <td><span class="badge badge-warning">Chunking + Compression</span></td>
                                <td>Best performance</td>
                            </tr>
                            <tr>
                                <td>Small Data</td>
                                <td><50KB</td>
                                <td><span class="badge badge-info">None</span></td>
                                <td>Fastest performance</td>
                            </tr>
                        </tbody>
                    </table>

                    <h2>üéØ Adaptive Compression</h2>
                    <p>Auto-optimize compression levels based on data characteristics:</p>

                    <pre><code class="language-php">// Enable adaptive compression
config(['smart-cache.strategies.compression.mode' => 'adaptive']);

// Automatically selects optimal compression level:
// - Hot data (frequently accessed) = level 3-4 (faster)
// - Cold data (rarely accessed) = level 7-9 (smaller)
// - Based on compressibility analysis

SmartCache::put('hot_data', $frequentlyAccessed, 3600);
SmartCache::put('cold_data', $rarelyAccessed, 3600);</code></pre>

                    <h2>üíæ Lazy Loading</h2>
                    <p>Load large datasets on-demand, keeping only the active chunk in memory:</p>

                    <pre><code class="language-php">// Enable lazy loading
config(['smart-cache.strategies.chunking.lazy_loading' => true]);

// Returns LazyChunkedCollection - loads chunks on-demand
$largeDataset = SmartCache::get('100k_records');

foreach ($largeDataset as $record) {
    processRecord($record);
    // Only 3 chunks in memory at once
}</code></pre>

                    <h2>üß† Smart Serialization</h2>
                    <p>Auto-select best serialization method:</p>

                    <pre><code class="language-php">// Automatically chooses:
// - JSON for simple arrays (fastest)
// - igbinary for complex data (if available)
// - PHP serialize as fallback

SmartCache::put('data', $value, 3600);
// Best method selected automatically</code></pre>

                    <h2>üìè Smart Chunk Sizing</h2>
                    <p>Auto-calculate optimal chunk sizes based on cache driver:</p>

                    <pre><code class="language-php">// Enable smart chunk sizing
config(['smart-cache.strategies.chunking.smart_sizing' => true]);

// Automatically calculates optimal chunk size based on:
// - Cache driver limits (Redis: 512MB, Memcached: 1MB)
// - Data structure complexity
// - Serialization overhead

SmartCache::put('large_array', $data, 3600);
// Optimal chunk size calculated automatically</code></pre>

                    <h2>Configuration Options</h2>
                    <pre><code class="language-php">// config/smart-cache.php
return [
    'thresholds' => [
        'compression' => 1024 * 50, // 50KB
        'chunking' => 1024 * 100,   // 100KB
    ],

    'strategies' => [
        'compression' => [
            'enabled' => true,
            'mode' => 'fixed',       // 'fixed' or 'adaptive'
            'level' => 6,            // 1-9 (higher = better compression)
        ],
        'chunking' => [
            'enabled' => true,
            'chunk_size' => 1000,    // Items per chunk
            'lazy_loading' => false, // Enable for memory savings
            'smart_sizing' => false, // Auto-calculate chunk size
        ],
    ],

    'events' => [
        'enabled' => false,          // Enable for monitoring
    ],

    'monitoring' => [
        'enabled' => true,
        'metrics_ttl' => 3600,
    ],
];</code></pre>

                    <h2>What to Expect</h2>
                    <div class="alert alert-success">
                        <strong>Typical improvements</strong> depend on your data shapes and access patterns. Compression is most effective on large text and repetitive structures; chunking benefits datasets that exceed driver size limits. Enable monitoring to measure the actual impact in your environment.
                    </div>
                </div>

                <!-- SWR Patterns Tab -->
                <div id="swr-patterns" class="tab-container">
                    <h1>üåä SWR Patterns (Laravel 12+)</h1>
                    
                    <div class="alert alert-info">
                        <strong>Note:</strong> SWR patterns require Laravel 12 or higher. For older versions, use the standard caching methods.
                    </div>

                    <h2>What is SWR?</h2>
                    <p>SWR (Stale-While-Revalidate) is a caching strategy that serves stale data immediately while refreshing it in the background. This provides:</p>
                    <ul>
                        <li>‚ö° <strong>Instant responses</strong> - Users see data immediately</li>
                        <li>üîÑ <strong>Fresh data</strong> - Background updates ensure data stays current</li>
                        <li>üö´ <strong>No cache stampede</strong> - Prevents multiple simultaneous requests</li>
                    </ul>

                    <h2>Basic SWR Usage</h2>
                    <pre><code class="language-php">// SWR: Serve stale data while refreshing in background
$apiData = SmartCache::swr('github_repos', function() {
    return Http::get('https://api.github.com/user/repos')->json();
}, 300, 900); // 5min fresh, 15min stale</code></pre>

                    <h2>Extended Stale Serving</h2>
                    <p>For slowly changing data, serve stale data for extended periods:</p>

                    <pre><code class="language-php">// Extended stale serving for site configuration
$siteConfig = SmartCache::stale('site_config', function() {
    return Config::fromDatabase();
}, 3600, 86400); // 1hour fresh, 24hour stale</code></pre>

                    <h2>Refresh-Ahead Caching</h2>
                    <p>Proactively refresh cache before expiration:</p>

                    <pre><code class="language-php">// Refresh-ahead for expensive computations
$analytics = SmartCache::refreshAhead('daily_analytics', function() {
    return Analytics::generateReport();
}, 1800, 300); // 30min TTL, 5min refresh window</code></pre>

                    <h2>Queue-Based Background Refresh</h2>
                    <p>Return stale data immediately and refresh asynchronously via a queued job:</p>

                    <pre><code class="language-php">// Returns stale data instantly, dispatches a background job to refresh
$data = SmartCache::asyncSwr('dashboard_stats', function() {
    return Stats::generate();
}, 300, 900, 'cache-refresh'); // 5min fresh, 15min stale, dispatched to 'cache-refresh' queue</code></pre>

                    <h2>Real-World Examples</h2>

                    <h3>API Gateway Cache</h3>
                    <pre><code class="language-php">class ApiController
{
    public function getProducts()
    {
        return SmartCache::swr('api_products', function() {
            return Product::with('images', 'reviews')->get();
        }, 300, 900); // 5min fresh, 15min stale
    }
    
    public function getUserProfile($userId)
    {
        return SmartCache::stale("user_profile_{$userId}", function() use ($userId) {
            return User::with('profile', 'settings')->find($userId);
        }, 1800, 3600); // 30min fresh, 1hour stale
    }
}</code></pre>

                    <h3>E-commerce Product Recommendations</h3>
                    <pre><code class="language-php">class RecommendationService
{
    public function getRecommendations($userId)
    {
        return SmartCache::refreshAhead(
            "recommendations_{$userId}",
            function() use ($userId) {
                return $this->aiEngine->generateRecommendations($userId);
            },
            3600, 600 // 1hour TTL, 10min refresh window
        );
    }
}</code></pre>
                </div>

                <!-- Monitoring Tab -->
                <div id="monitoring" class="tab-container">
                    <h1>üìä Performance Monitoring</h1>
                    
                    <h2>Real-Time Metrics</h2>
                    <p>Get comprehensive performance metrics about your cache usage:</p>

                    <pre><code class="language-php">// Get all performance metrics
$metrics = SmartCache::getPerformanceMetrics();

/*
Returns:
[
    'cache_efficiency' => [
        'hit_ratio' => 0.943,
        'miss_ratio' => 0.057,
        'total_requests' => 1000
    ],
    'optimization_impact' => [
        'compression_savings' => 0.68,
        'chunking_benefits' => 0.23,
        'total_size_reduction' => 0.72
    ],
    'operation_timing' => [
        'average_get_time' => 0.023,
        'average_put_time' => 0.045,
        'total_operations' => 5000
    ]
]
*/</code></pre>

                    <h2>Health Analysis</h2>
                    <p>Get automated analysis and recommendations:</p>

                    <pre><code class="language-php">// Automated performance analysis
$analysis = SmartCache::analyzePerformance();

/*
Returns:
[
    'overall_health' => 'good', // good, warning, critical
    'recommendations' => [
        'Consider increasing cache TTL for frequently accessed data',
        'Enable compression for large text data'
    ],
    'issues' => [],
    'score' => 85
]
*/</code></pre>

                    <h2>HTTP Command Execution</h2>
                    <p>Manage cache via HTTP API (perfect for web-based admin panels):</p>

                    <pre><code class="language-php">// Get available commands
$commands = SmartCache::getAvailableCommands();

// Execute commands via HTTP
$status = SmartCache::executeCommand('status');
$clearResult = SmartCache::executeCommand('clear');
$specificClear = SmartCache::executeCommand('clear', [
    'key' => 'expensive_computation',
    'force' => true
]);</code></pre>

                    <h2>CLI Commands</h2>
                    <pre><code class="language-bash"># Quick status overview
php artisan smart-cache:status

# Detailed analysis with recommendations
php artisan smart-cache:status --force

# Clear all SmartCache managed keys
php artisan smart-cache:clear

# Clear specific key
php artisan smart-cache:clear expensive_api_call

# Force clear any cache key
php artisan smart-cache:clear --force</code></pre>
                </div>

                <!-- Advanced Tab -->
                <div id="advanced" class="tab-container">
                    <h1>üîß Advanced Features</h1>

                    <div class="alert alert-info">
                        All advanced features are opt-in and backwards-compatible: Atomic Locks, Memoization, Events, Adaptive Compression, Lazy Loading, Smart Invalidation, and more.
                    </div>

                    <h2>üîí Atomic Locks</h2>
                    <p>Prevent multiple processes from regenerating expensive cache simultaneously (prevents race conditions):</p>

                    <pre><code class="language-php">// Prevent cache stampede with distributed locks
$lock = SmartCache::lock('expensive_operation', 10);

if ($lock->get()) {
    // Only one process executes this
    $data = expensiveApiCall();
    SmartCache::put('api_data', $data, 3600);
    $lock->release();
}

// Or use callback pattern for automatic release
SmartCache::lock('regenerate_cache', 30)->get(function() {
    return regenerateExpensiveData();
});</code></pre>



                    <h2>‚ö° Cache Memoization</h2>
                    <p>Hold retrieved values in memory for the duration of a request or job, eliminating repeated cache lookups:</p>

                    <pre><code class="language-php">// Get memoized cache instance
$memo = SmartCache::memo();

// First call hits cache, subsequent calls are instant (from memory)
$users = $memo->remember('users', 3600, fn() => User::all());
$users = $memo->get('users'); // From memory ‚Äî no cache round-trip
$users = $memo->get('users'); // Still from memory

// Perfect for loops and repeated access
foreach ($products as $product) {
    $category = $memo->get("category_{$product->category_id}");
    // First access hits cache, subsequent accesses are instant
}

// Get memoization statistics
$stats = $memo->getMemoizationStats();
// Returns: memoized_count, missing_count, total_memory</code></pre>



                    <h2>üì° Cache Events</h2>
                    <p>Monitor and react to cache operations in real-time:</p>

                    <pre><code class="language-php">// Enable events in config
config(['smart-cache.events.enabled' => true]);

// Listen to cache operations
use SmartCache\Events\{CacheHit, CacheMissed, KeyWritten, KeyForgotten, OptimizationApplied};

Event::listen(CacheHit::class, function ($event) {
    Log::info("Cache hit: {$event->key}", ['tags' => $event->tags]);
});

Event::listen(CacheMissed::class, function ($event) {
    Log::warning("Cache miss: {$event->key}");
});

Event::listen(OptimizationApplied::class, function ($event) {
    Log::info("Optimized {$event->key}: {$event->strategy} - {$event->ratio}% reduction");
});</code></pre>

                    <div class="alert alert-warning">
                        <strong>Note:</strong> Events are disabled by default for performance. Enable only when you need monitoring.
                    </div>

                    <h2>üî¢ Batch Operations</h2>
                    <p>Optimize multiple cache operations:</p>

                    <pre><code class="language-php">// Retrieve multiple keys at once
$values = SmartCache::many(['key1', 'key2', 'key3']);

// Store multiple keys at once
SmartCache::putMany([
    'key1' => 'value1',
    'key2' => 'value2',
    'key3' => 'value3',
], 3600);

// Delete multiple keys at once
SmartCache::deleteMultiple(['key1', 'key2', 'key3']);</code></pre>

                    <h2>üéØ Adaptive Compression</h2>
                    <p>Auto-optimize compression levels based on data characteristics:</p>

                    <pre><code class="language-php">// Enable adaptive compression in config
config(['smart-cache.strategies.compression.mode' => 'adaptive']);

// Automatically selects optimal compression level based on:
// - Data compressibility (sample-based analysis)
// - Access frequency (hot data = faster compression)
// - Data size (larger data = higher compression)

SmartCache::put('hot_data', $frequentlyAccessed, 3600);  // Uses level 3-4 (faster)
SmartCache::put('cold_data', $rarelyAccessed, 3600);     // Uses level 7-9 (smaller)

// Get compression statistics
$stats = SmartCache::getCompressionStats($optimizedValue);
// Returns: level, original_size, compressed_size, ratio, savings_bytes, savings_percent</code></pre>

                    <h2>üíæ Lazy Loading</h2>
                    <p>Load large datasets on-demand, keeping only the active chunk in memory:</p>

                    <pre><code class="language-php">// Enable lazy loading in config
config(['smart-cache.strategies.chunking.lazy_loading' => true]);

// Large datasets return LazyChunkedCollection
$largeDataset = SmartCache::get('100k_records');

// Chunks loaded on-demand (max 3 in memory at once)
foreach ($largeDataset as $record) {
    processRecord($record);
    // Only loads chunks as needed
}

// Access specific items
$item = $largeDataset[50000]; // Only loads the chunk containing this item

// Collection methods work too
$filtered = $largeDataset->filter(fn($item) => $item->active);
$mapped = $largeDataset->map(fn($item) => $item->name);</code></pre>

                    <h2>üß† Smart Serialization</h2>
                    <p>Auto-select best serialization method for optimal performance:</p>

                    <pre><code class="language-php">// Automatically chooses best method:
// - JSON for simple arrays (fastest, most compact)
// - igbinary for complex data (if available)
// - PHP serialize as fallback

SmartCache::put('simple_data', ['key' => 'value'], 3600);  // Uses JSON
SmartCache::put('complex_data', $objectGraph, 3600);       // Uses igbinary/PHP

// Get serialization statistics
$stats = SmartCache::getSerializationStats($optimizedValue);
// Returns: method, original_size, serialized_size, ratio</code></pre>

                    <h2>Smart Cache Invalidation</h2>

                    <h3>Dependency Tracking</h3>
                    <p>Create cache hierarchies where invalidating a parent clears all children:</p>

                    <pre><code class="language-php">// Create cache dependencies
SmartCache::dependsOn('user_posts', 'user_profile');
SmartCache::dependsOn('user_stats', 'user_profile');

// Invalidate parent - children cleared automatically
SmartCache::invalidate('user_profile');
// This will also clear 'user_posts' and 'user_stats'</code></pre>

                    <h3>Pattern-Based Invalidation</h3>
                    <p>Clear cache entries using wildcards and regex patterns:</p>

                    <pre><code class="language-php">// Pattern-based clearing
SmartCache::flushPatterns([
    'user_*',           // All user keys
    'api_v2_*',         // All API v2 cache
    '/product_\d+/'     // Regex: product_123, product_456
]);</code></pre>

                    <h3>Model Auto-Invalidation</h3>
                    <p>Automatically clear cache when Eloquent models change:</p>

                    <pre><code class="language-php">use SmartCache\Traits\CacheInvalidation;

class User extends Model
{
    use CacheInvalidation;
    
    public function getCacheKeysToInvalidate(): array
    {
        return [
            "user_{$this->id}_profile",
            "user_{$this->id}_posts",
            'users_list_*'
        ];
    }
}

// Cache automatically cleared when user changes!
$user = User::find(1);
$user->update(['name' => 'New Name']); // Cache cleared automatically</code></pre>

                    <h2>Custom Optimization Strategies</h2>
                    <p>Create custom optimization strategies for your specific needs:</p>

                    <pre><code class="language-php">use SmartCache\Contracts\OptimizationStrategy;

class JsonCompressionStrategy implements OptimizationStrategy
{
    public function shouldApply(mixed $value, array $context = []): bool
    {
        return is_array($value) && 
               json_encode($value, JSON_UNESCAPED_UNICODE) !== false &&
               strlen(json_encode($value)) > 10240; // 10KB threshold
    }
    
    public function optimize(mixed $value, array $context = []): mixed
    {
        $json = json_encode($value, JSON_UNESCAPED_UNICODE);
        return [
            '_sc_json_compressed' => true,
            'data' => gzcompress($json, 9)
        ];
    }
    
    public function restore(mixed $value, array $context = []): mixed
    {
        if (is_array($value) && ($value['_sc_json_compressed'] ?? false)) {
            return json_decode(gzuncompress($value['data']), true);
        }
        return $value;
    }
    
    public function getIdentifier(): string
    {
        return 'json_compression';
    }
}

// Register your custom strategy
SmartCache::addStrategy(new JsonCompressionStrategy());</code></pre>

                </div>

                <!-- Extended Features Tab -->
                <div id="extended-features" class="tab-container">
                    <h1>‚ú® Extended Features</h1>

                    <div class="alert alert-info">
                        All extended features are opt-in and backwards-compatible: Cost-Aware Caching, Encryption at Rest, Namespacing, TTL Jitter, Circuit Breaker, Rate Limiting, Cache Warming, and more.
                    </div>

                    <h2>üîê Encryption Strategy</h2>
                    <p>Encrypt sensitive cached data automatically:</p>

                    <pre><code class="language-php">// Configure encryption in config/smart-cache.php
'encryption' => [
    'enabled' => true,
    'keys' => ['user_*', 'payment_*'],     // Keys to encrypt
    'patterns' => ['/secret_.*/'],          // Regex patterns
],

// Data matching patterns is automatically encrypted
SmartCache::put('user_123_data', $sensitiveData, 3600);
// Automatically encrypted at rest

// Decryption is automatic on retrieval
$data = SmartCache::get('user_123_data');
// Returns decrypted data</code></pre>

                    <h2>üìÅ Cache Namespacing</h2>
                    <p>Group cache keys by namespace for better organization:</p>

                    <pre><code class="language-php">// Set active namespace
SmartCache::namespace('api_v2');

// All operations now use this namespace
SmartCache::put('users', $users, 3600);  // Actually stores 'api_v2:users'
SmartCache::get('users');                 // Gets 'api_v2:users'

// Flush entire namespace
SmartCache::flushNamespace('api_v2');

// Get all keys in namespace
$keys = SmartCache::getNamespaceKeys('api_v2');

// Disable namespace temporarily
SmartCache::withoutNamespace()->put('global_key', $value, 3600);</code></pre>

                    <h2>‚è±Ô∏è TTL Jitter</h2>
                    <p>Prevent thundering herd by adding random variation to TTL:</p>

                    <pre><code class="language-php">// Enable jitter globally in config
'jitter' => [
    'enabled' => true,
    'percentage' => 0.1,  // 10% variation
],

// Or enable per-operation
SmartCache::withJitter(0.15)->put('key', $value, 3600);
// TTL will be 3060-3540 seconds (¬±15%)

// Use jitter-specific methods
SmartCache::putWithJitter('key', $value, 3600, 0.2);
SmartCache::rememberWithJitter('key', 3600, fn() => $value, 0.1);</code></pre>

                    <div class="alert alert-info">
                        <strong>Why Jitter?</strong> When many cache entries expire at the same time, they all try to regenerate simultaneously (thundering herd). Jitter spreads out expirations to prevent this.
                    </div>

                    <h2>üîå Circuit Breaker</h2>
                    <p>Protect your application from cache backend failures:</p>

                    <pre><code class="language-php">// Configure circuit breaker
'circuit_breaker' => [
    'enabled' => true,
    'failure_threshold' => 5,   // Open after 5 failures
    'success_threshold' => 2,   // Close after 2 successes
    'timeout' => 30,            // Try again after 30 seconds
],

// Check if cache is available
if (SmartCache::isAvailable()) {
    $data = SmartCache::get('key');
} else {
    $data = $this->fallbackSource();
}

// Use fallback automatically
$data = SmartCache::withFallback(
    fn() => SmartCache::get('key'),
    fn() => $this->fallbackSource()
);

// Get circuit breaker statistics
$stats = SmartCache::getCircuitBreakerStats();
// Returns: state, failures, successes, last_failure_time</code></pre>

                    <h2>üö¶ Rate Limiting & Stampede Protection</h2>
                    <p>Prevent cache stampede with probabilistic early expiration:</p>

                    <pre><code class="language-php">// Throttle cache regeneration
SmartCache::throttle('expensive_key', 10, 60, function() {
    return expensiveOperation();
}); // Max 10 regenerations per 60 seconds

// Stampede protection with XFetch algorithm
$data = SmartCache::rememberWithStampedeProtection(
    'popular_key',
    3600,
    fn() => expensiveQuery(),
    1.0  // Beta factor (higher = earlier refresh)
);

// Configure rate limiter
'rate_limiter' => [
    'enabled' => true,
    'default_limit' => 100,
    'window' => 60,
],</code></pre>

                    <h2>üî• Cache Warming</h2>
                    <p>Pre-populate cache with frequently accessed data:</p>

                    <pre><code class="language-php">// Create a cache warmer
use SmartCache\Contracts\CacheWarmer;

class ProductCacheWarmer implements CacheWarmer
{
    public function warm(): void
    {
        $products = Product::with('images')->get();
        SmartCache::put('all_products', $products, 3600);
    }

    public function getKeys(): array
    {
        return ['all_products'];
    }
}

// Register in service provider
$this->app->tag([ProductCacheWarmer::class], 'cache.warmers');

// Run cache warming command
php artisan smart-cache:warm

// Or warm specific keys
php artisan smart-cache:warm --keys=all_products,categories</code></pre>

                    <h2>üßπ Orphan Chunk Cleanup</h2>
                    <p>Automatically clean up orphaned chunks from expired data:</p>

                    <pre><code class="language-php">// Run cleanup command
php artisan smart-cache:cleanup-chunks

// Schedule automatic cleanup
// In app/Console/Kernel.php
$schedule->command('smart-cache:cleanup-chunks')->daily();

// Cleanup is also triggered automatically when:
// - A chunked key is forgotten
// - A chunked key expires and is accessed</code></pre>

                    <h2>üìä Cache Statistics Dashboard</h2>
                    <p>Visual dashboard for monitoring cache performance:</p>

                    <pre><code class="language-php">// Enable dashboard in config
'dashboard' => [
    'enabled' => true,
    'prefix' => 'smart-cache',
    'middleware' => ['web', 'auth'],
],

// Access dashboard at:
// GET /smart-cache/dashboard

// JSON API endpoints:
// GET /smart-cache/stats     - Performance metrics
// GET /smart-cache/health    - Health check
// GET /smart-cache/keys      - Managed keys list</code></pre>

                    <h2>üîÑ Background Refresh</h2>
                    <p>Queue-based background cache refresh:</p>

                    <pre><code class="language-php">use SmartCache\Jobs\BackgroundCacheRefreshJob;

// Dispatch background refresh
BackgroundCacheRefreshJob::dispatch(
    'expensive_key',
    fn() => expensiveOperation(),
    3600
);

// Or use asyncSwr ‚Äî returns stale data immediately, refreshes via queue
SmartCache::asyncSwr('key', fn() => $data, 300, 900, 'cache-refresh');</code></pre>

                    <h2>üß† Cost-Aware Caching</h2>
                    <p>Inspired by the GreedyDual-Size algorithm, every <code>remember()</code> call automatically tracks regeneration cost, access frequency, and data size to compute a value score ‚Äî letting you make data-driven eviction decisions.</p>

                    <div class="alert alert-info">
                        <strong>How it works:</strong> Each cache entry receives a score calculated as <code>score = (cost √ó ln(1 + access_count) √ó decay) / size</code>. Expensive, frequently accessed, small entries score highest. Cheap, rarely used, large entries score lowest.
                    </div>

                    <pre><code class="language-php">// Automatic ‚Äî just use remember() as usual
$report = SmartCache::remember('analytics', 3600, function () {
    return AnalyticsService::generateReport(); // 800ms callback
});

$users = SmartCache::remember('users', 3600, function () {
    return User::all(); // 5ms callback
});

// See which cache entries are most valuable
$report = SmartCache::getCacheValueReport();
// [
//   ['key' => 'analytics', 'cost_ms' => 800, 'access_count' => 47, 'score' => 92.4],
//   ['key' => 'users',     'cost_ms' => 5,   'access_count' => 120, 'score' => 14.1],
// ]

// Get value score for a specific key
$meta = SmartCache::cacheValue('analytics');
// ['cost_ms' => 800, 'access_count' => 47, 'size_bytes' => 4096, 'score' => 92.4]

// When you need to free space, find the least valuable entries
$evictable = SmartCache::suggestEvictions(5);
// Returns the 5 lowest-score keys ‚Äî safe to remove first</code></pre>

                    <div class="alert alert-success">
                        Useful for production monitoring, capacity planning, and intelligent eviction policies ‚Äî know exactly which keys matter and which waste space.
                    </div>

                    <h2>Configuration Reference</h2>
                    <pre><code class="language-php">// config/smart-cache.php
return [
    // ... existing options ...

    'encryption' => [
        'enabled' => false,
        'keys' => [],
        'patterns' => [],
    ],

    'circuit_breaker' => [
        'enabled' => true,
        'failure_threshold' => 5,
        'success_threshold' => 2,
        'timeout' => 30,
    ],

    'rate_limiter' => [
        'enabled' => true,
        'default_limit' => 100,
        'window' => 60,
    ],

    'jitter' => [
        'enabled' => false,
        'percentage' => 0.1,
    ],

    'cost_aware' => [
        'enabled' => true,              // Toggle cost tracking on/off
        'max_tracked_keys' => 1000,     // Limit metadata memory
        'metadata_ttl' => 86400,        // Metadata persistence (1 day)
    ],

    'dashboard' => [
        'enabled' => false,
        'prefix' => 'smart-cache',
        'middleware' => ['web'],
    ],
];</code></pre>
                </div>

                <!-- API Reference Tab -->
                <div id="api-reference" class="tab-container">
                    <h1>üìö API Reference</h1>

                    <div class="alert alert-info">
                        All public methods, parameters, and return types with examples.
                    </div>

                    <h2 id="basic-ops">üîß Basic Cache Operations</h2>
                    
                    <div class="method">
                        <div class="method-name">SmartCache::get()</div>
                        <div class="method-signature">SmartCache::get(string $key, mixed $default = null): mixed</div>
                        <p>Retrieve an item from the cache with automatic restoration of optimized data.</p>
                        <div class="parameter">
                            <span class="parameter-name">$key</span> <span class="parameter-type">(string)</span> - The cache key
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$default</span> <span class="parameter-type">(mixed)</span> - Default value if key doesn't exist
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> mixed - The cached value or default
                        </div>
                        <div class="example">
                            <strong>Examples:</strong>
                            <pre><code class="language-php">$users = SmartCache::get('users', []);
$config = SmartCache::get('app_config', collect());</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::put()</div>
                        <div class="method-signature">SmartCache::put(string $key, mixed $value, DateTimeInterface|DateInterval|int|null $ttl = null): bool</div>
                        <p>Store an item in the cache with automatic optimization (compression/chunking).</p>
                        <div class="parameter">
                            <span class="parameter-name">$key</span> <span class="parameter-type">(string)</span> - The cache key
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$value</span> <span class="parameter-type">(mixed)</span> - The value to store
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$ttl</span> <span class="parameter-type">(DateTimeInterface|DateInterval|int|null)</span> - Time to live
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> bool - True on success
                        </div>
                        <div class="example">
                            <strong>Examples:</strong>
                            <pre><code class="language-php">SmartCache::put('users', $users, 3600);
SmartCache::put('config', $config, now()->addHours(2));</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::remember()</div>
                        <div class="method-signature">SmartCache::remember(string $key, DateTimeInterface|DateInterval|int|null $ttl, Closure $callback): mixed</div>
                        <p>Get an item from the cache, or execute the callback and store the result.</p>
                        <div class="parameter">
                            <span class="parameter-name">$key</span> <span class="parameter-type">(string)</span> - The cache key
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$ttl</span> <span class="parameter-type">(DateTimeInterface|DateInterval|int|null)</span> - Time to live
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$callback</span> <span class="parameter-type">(Closure)</span> - Function to generate fresh data
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> mixed - Cached or fresh data
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">$users = SmartCache::remember('users', 3600, function() {
    return User::with('profile')->get();
});</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::has()</div>
                        <div class="method-signature">SmartCache::has(string $key): bool</div>
                        <p>Determine if an item exists in the cache.</p>
                        <div class="parameter">
                            <span class="parameter-name">$key</span> <span class="parameter-type">(string)</span> - The cache key
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> bool - True if exists
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">if (SmartCache::has('users')) {
    $users = SmartCache::get('users');
}</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::forget()</div>
                        <div class="method-signature">SmartCache::forget(string $key): bool</div>
                        <p>Remove an item from the cache, including any optimized chunks.</p>
                        <div class="parameter">
                            <span class="parameter-name">$key</span> <span class="parameter-type">(string)</span> - The cache key
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> bool - True on success
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">SmartCache::forget('users');</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::store()</div>
                        <div class="method-signature">SmartCache::store(string|null $name = null): static</div>
                        <p>Get a SmartCache instance for a specific cache driver. All SmartCache optimizations (compression, chunking, encryption, etc.) are preserved. The returned instance also implements <code>Illuminate\Contracts\Cache\Repository</code> for full Laravel compatibility.</p>
                        <div class="parameter">
                            <span class="parameter-name">$name</span> <span class="parameter-type">(string|null)</span> - The cache store name (redis, file, memcached, etc.)
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> static - SmartCache instance configured for the specified store (also implements Repository)
                        </div>
                        <div class="example">
                            <strong>Examples:</strong>
                            <pre><code class="language-php">// Use Redis with all SmartCache optimizations
SmartCache::store('redis')->put('key', $value, 3600);
SmartCache::store('redis')->get('key');

// Use Memcached with optimizations
SmartCache::store('memcached')->remember('users', 3600, fn() => User::all());

// Chain operations on a specific store
$redisCache = SmartCache::store('redis');
$redisCache->put('users', $users, 3600);
$redisCache->put('products', $products, 3600);

// Works with Repository type hints
function cacheData(\Illuminate\Contracts\Cache\Repository $cache) {
    $cache->put('key', 'value', 3600);
}
cacheData(SmartCache::store('redis')); // ‚úÖ Works</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::repository()</div>
                        <div class="method-signature">SmartCache::repository(string|null $name = null): \Illuminate\Contracts\Cache\Repository</div>
                        <p>Get direct access to Laravel's underlying cache repository. This bypasses all SmartCache optimizations.</p>
                        <div class="parameter">
                            <span class="parameter-name">$name</span> <span class="parameter-type">(string|null)</span> - The cache store name (redis, file, memcached, etc.)
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> Repository - Laravel's native cache repository
                        </div>
                        <div class="example">
                            <strong>Examples:</strong>
                            <pre><code class="language-php">// Direct access to Redis cache (no SmartCache optimizations)
SmartCache::repository('redis')->put('key', $value, 3600);

// Direct access to default cache store
SmartCache::repository()->get('key');</code></pre>
                        </div>
                        <div class="alert alert-warning" style="margin-top: 10px;">
                            <strong>Note:</strong> Use <code>repository()</code> only when you need to bypass SmartCache optimizations. For normal usage, prefer <code>store()</code> to maintain all optimization benefits.
                        </div>
                    </div>

                    <h2 id="swr-api">üåä SWR Patterns (Laravel 12+)</h2>

                    <div class="method">
                        <div class="method-name">SmartCache::swr() <span class="badge badge-info">Laravel 12+</span></div>
                        <div class="method-signature">SmartCache::swr(string $key, Closure $callback, int $ttl = 3600, int $staleTtl = 7200): mixed</div>
                        <p>Stale-While-Revalidate pattern - serves stale data while refreshing in background.</p>
                        <div class="parameter">
                            <span class="parameter-name">$key</span> <span class="parameter-type">(string)</span> - The cache key
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$callback</span> <span class="parameter-type">(Closure)</span> - Function to generate fresh data
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$ttl</span> <span class="parameter-type">(int)</span> - Fresh data TTL in seconds
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$staleTtl</span> <span class="parameter-type">(int)</span> - Stale data TTL in seconds
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> mixed - Fresh or stale data
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">$apiData = SmartCache::swr('github_repos', function() {
    return Http::get('https://api.github.com/user/repos')->json();
}, 300, 900); // 5min fresh, 15min stale</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::stale() <span class="badge badge-info">Laravel 12+</span></div>
                        <div class="method-signature">SmartCache::stale(string $key, Closure $callback, int $ttl = 1800, int $staleTtl = 86400): mixed</div>
                        <p>Extended stale serving - allows serving stale data for extended periods.</p>
                        <div class="parameter">
                            <span class="parameter-name">$key</span> <span class="parameter-type">(string)</span> - The cache key
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$callback</span> <span class="parameter-type">(Closure)</span> - Function to generate fresh data
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$ttl</span> <span class="parameter-type">(int)</span> - Fresh data TTL in seconds
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$staleTtl</span> <span class="parameter-type">(int)</span> - Stale data TTL in seconds
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> mixed - Fresh or stale data
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">$siteConfig = SmartCache::stale('site_config', function() {
    return Config::fromDatabase();
}, 3600, 86400); // 1hour fresh, 24hour stale</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::refreshAhead() <span class="badge badge-info">Laravel 12+</span></div>
                        <div class="method-signature">SmartCache::refreshAhead(string $key, Closure $callback, int $ttl = 3600, int $refreshWindow = 600): mixed</div>
                        <p>Refresh-ahead pattern - proactively refreshes cache before expiration.</p>
                        <div class="parameter">
                            <span class="parameter-name">$key</span> <span class="parameter-type">(string)</span> - The cache key
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$callback</span> <span class="parameter-type">(Closure)</span> - Function to generate fresh data
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$ttl</span> <span class="parameter-type">(int)</span> - Cache TTL in seconds
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$refreshWindow</span> <span class="parameter-type">(int)</span> - Refresh window in seconds
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> mixed - Cached or fresh data
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">$analytics = SmartCache::refreshAhead('daily_analytics', function() {
    return Analytics::generateReport();
}, 1800, 300); // 30min TTL, 5min refresh window</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::asyncSwr() <span class="badge badge-info">Laravel 12+</span></div>
                        <div class="method-signature">SmartCache::asyncSwr(string $key, callable|string $callback, int $ttl = 3600, int $staleTtl = 7200, ?string $queue = null): mixed</div>
                        <p>Queue-based background SWR ‚Äî returns stale data immediately and dispatches a queued job to refresh the cache asynchronously.</p>
                        <div class="parameter">
                            <span class="parameter-name">$key</span> <span class="parameter-type">(string)</span> - The cache key
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$callback</span> <span class="parameter-type">(callable|string)</span> - Function to generate fresh data
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$ttl</span> <span class="parameter-type">(int)</span> - Fresh TTL in seconds
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$staleTtl</span> <span class="parameter-type">(int)</span> - Maximum stale time in seconds
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$queue</span> <span class="parameter-type">(?string)</span> - Queue name for the background refresh job
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> mixed - Fresh or stale data
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">$data = SmartCache::asyncSwr('dashboard_stats', function() {
    return Stats::generate();
}, 300, 900, 'cache-refresh'); // 5min fresh, 15min stale, queued on 'cache-refresh'</code></pre>
                        </div>
                    </div>

                    <h2 id="invalidation-api">üîó Cache Invalidation & Dependencies</h2>

                    <div class="method">
                        <div class="method-name">SmartCache::tags()</div>
                        <div class="method-signature">SmartCache::tags(string|array $tags): static</div>
                        <p>Tag cache entries for organized invalidation.</p>
                        <div class="parameter">
                            <span class="parameter-name">$tags</span> <span class="parameter-type">(string|array)</span> - Tag name(s)
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> static - Chainable instance
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">SmartCache::tags(['users', 'profiles'])->put('user_1', $user1, 3600);
SmartCache::tags('products')->put('product_123', $product, 1800);</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::flushTags()</div>
                        <div class="method-signature">SmartCache::flushTags(string|array $tags): bool</div>
                        <p>Flush all cache entries associated with given tags.</p>
                        <div class="parameter">
                            <span class="parameter-name">$tags</span> <span class="parameter-type">(string|array)</span> - Tag name(s)
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> bool - True on success
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">SmartCache::flushTags(['users']); // Clear all user-related cache</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::dependsOn()</div>
                        <div class="method-signature">SmartCache::dependsOn(string $key, string|array $dependencies): static</div>
                        <p>Add cache key dependency relationships.</p>
                        <div class="parameter">
                            <span class="parameter-name">$key</span> <span class="parameter-type">(string)</span> - The dependent cache key
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$dependencies</span> <span class="parameter-type">(string|array)</span> - Parent key(s)
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> static - Chainable instance
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">SmartCache::dependsOn('user_posts', 'user_profile');</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::flushPatterns()</div>
                        <div class="method-signature">SmartCache::flushPatterns(array $patterns): int</div>
                        <p>Clear cache entries matching wildcard or regex patterns.</p>
                        <div class="parameter">
                            <span class="parameter-name">$patterns</span> <span class="parameter-type">(array)</span> - Array of patterns (wildcards or regex)
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> int - Number of keys cleared
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">$cleared = SmartCache::flushPatterns([
    'user_*',           // All user keys
    'api_v2_*',         // All API v2 cache
    '/product_\d+/'     // Regex: product_123, product_456
]);</code></pre>
                        </div>
                    </div>

                    <h2 id="monitoring-api">üìä Performance Monitoring</h2>

                    <div class="method">
                        <div class="method-name">SmartCache::getPerformanceMetrics()</div>
                        <div class="method-signature">SmartCache::getPerformanceMetrics(): array</div>
                        <p>Get comprehensive performance metrics about cache usage.</p>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> array - Performance metrics including hit ratios, timing, and optimization impact
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">$metrics = SmartCache::getPerformanceMetrics();
/*
Returns:
[
    'cache_efficiency' => [
        'hit_ratio' => 0.943,
        'miss_ratio' => 0.057,
        'total_requests' => 1000
    ],
    'optimization_impact' => [
        'compression_savings' => 0.68,
        'chunking_benefits' => 0.23,
        'total_size_reduction' => 0.72
    ]
]
*/</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::analyzePerformance()</div>
                        <div class="method-signature">SmartCache::analyzePerformance(): array</div>
                        <p>Get automated performance analysis and recommendations.</p>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> array - Analysis with health status, recommendations, and score
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">$analysis = SmartCache::analyzePerformance();
/*
Returns:
[
    'overall_health' => 'good', // good, warning, critical
    'recommendations' => [
        'Consider increasing cache TTL for frequently accessed data'
    ],
    'score' => 85
]
*/</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::executeCommand()</div>
                        <div class="method-signature">SmartCache::executeCommand(string $command, array $parameters = []): array</div>
                        <p>Execute cache management commands programmatically.</p>
                        <div class="parameter">
                            <span class="parameter-name">$command</span> <span class="parameter-type">(string)</span> - Command to execute (status, clear, etc.)
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$parameters</span> <span class="parameter-type">(array)</span> - Command parameters
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> array - Command result
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">$status = SmartCache::executeCommand('status');
$result = SmartCache::executeCommand('clear', ['key' => 'specific_key']);</code></pre>
                        </div>
                    </div>

                    <h2 id="extended-features-api">üîß Extended API</h2>

                    <div class="method">
                        <div class="method-name">SmartCache::lock()</div>
                        <div class="method-signature">SmartCache::lock(string $name, int $seconds = 0, string|null $owner = null): \Illuminate\Contracts\Cache\Lock</div>
                        <p>Get a lock instance to prevent cache stampede and race conditions.</p>
                        <div class="parameter">
                            <span class="parameter-name">$name</span> <span class="parameter-type">(string)</span> - Lock name
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$seconds</span> <span class="parameter-type">(int)</span> - Lock timeout in seconds
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$owner</span> <span class="parameter-type">(string|null)</span> - Lock owner identifier
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> Lock - Lock instance
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">$lock = SmartCache::lock('expensive_operation', 10);
if ($lock->get()) {
    $data = expensiveApiCall();
    SmartCache::put('api_data', $data, 3600);
    $lock->release();
}</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::memo()</div>
                        <div class="method-signature">SmartCache::memo(): \SmartCache\Drivers\MemoizedCacheDriver</div>
                        <p>Get a memoized cache instance that holds values in memory for the current request.</p>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> MemoizedCacheDriver - Memoized cache instance
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">$memo = SmartCache::memo();
$users = $memo->remember('users', 3600, fn() => User::all());
$users = $memo->get('users'); // From memory ‚Äî no cache round-trip</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::many()</div>
                        <div class="method-signature">SmartCache::many(array $keys): array</div>
                        <p>Retrieve multiple cache keys at once.</p>
                        <div class="parameter">
                            <span class="parameter-name">$keys</span> <span class="parameter-type">(array)</span> - Array of cache keys
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> array - Associative array of key => value pairs
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">$values = SmartCache::many(['key1', 'key2', 'key3']);</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::putMany()</div>
                        <div class="method-signature">SmartCache::putMany(array $values, DateTimeInterface|DateInterval|int|null $ttl = null): bool</div>
                        <p>Store multiple cache keys at once.</p>
                        <div class="parameter">
                            <span class="parameter-name">$values</span> <span class="parameter-type">(array)</span> - Associative array of key => value pairs
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$ttl</span> <span class="parameter-type">(int|null)</span> - Time to live in seconds
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> bool - True on success
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">SmartCache::putMany([
    'key1' => 'value1',
    'key2' => 'value2',
], 3600);</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::deleteMultiple()</div>
                        <div class="method-signature">SmartCache::deleteMultiple(array $keys): bool</div>
                        <p>Delete multiple cache keys at once.</p>
                        <div class="parameter">
                            <span class="parameter-name">$keys</span> <span class="parameter-type">(array)</span> - Array of cache keys
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> bool - True on success
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">SmartCache::deleteMultiple(['key1', 'key2', 'key3']);</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::getCompressionStats()</div>
                        <div class="method-signature">SmartCache::getCompressionStats(mixed $optimizedValue): array</div>
                        <p>Get compression statistics for optimized data.</p>
                        <div class="parameter">
                            <span class="parameter-name">$optimizedValue</span> <span class="parameter-type">(mixed)</span> - Optimized value from cache
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> array - Compression stats (level, sizes, ratio, savings)
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">$optimized = SmartCache::optimize($data);
$stats = SmartCache::getCompressionStats($optimized);
// Returns: level, original_size, compressed_size, ratio, savings_bytes, savings_percent</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::getSerializationStats()</div>
                        <div class="method-signature">SmartCache::getSerializationStats(mixed $optimizedValue): array</div>
                        <p>Get serialization statistics for optimized data.</p>
                        <div class="parameter">
                            <span class="parameter-name">$optimizedValue</span> <span class="parameter-type">(mixed)</span> - Optimized value from cache
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> array - Serialization stats (method, sizes, ratio)
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">$optimized = SmartCache::optimize($data);
$stats = SmartCache::getSerializationStats($optimized);
// Returns: method, original_size, serialized_size, ratio</code></pre>
                        </div>
                    </div>

                    <h2 id="resilience-api">‚ú® Resilience & Organization API</h2>

                    <div class="method">
                        <div class="method-name">SmartCache::namespace()</div>
                        <div class="method-signature">SmartCache::namespace(string $namespace): static</div>
                        <p>Set the active namespace for cache operations.</p>
                        <div class="parameter">
                            <span class="parameter-name">$namespace</span> <span class="parameter-type">(string)</span> - Namespace prefix
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> static - Chainable instance
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">SmartCache::namespace('api_v2')->put('users', $users, 3600);
// Stores as 'api_v2:users'</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::flushNamespace()</div>
                        <div class="method-signature">SmartCache::flushNamespace(string $namespace): int</div>
                        <p>Flush all cache entries in a namespace.</p>
                        <div class="parameter">
                            <span class="parameter-name">$namespace</span> <span class="parameter-type">(string)</span> - Namespace to flush
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> int - Number of keys flushed
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">$count = SmartCache::flushNamespace('api_v2');
// Clears all keys prefixed with 'api_v2:'</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::withJitter()</div>
                        <div class="method-signature">SmartCache::withJitter(float $percentage = 0.1): static</div>
                        <p>Enable TTL jitter for subsequent operations.</p>
                        <div class="parameter">
                            <span class="parameter-name">$percentage</span> <span class="parameter-type">(float)</span> - Jitter percentage (0.1 = 10%)
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> static - Chainable instance
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">SmartCache::withJitter(0.15)->put('key', $value, 3600);
// TTL will be 3060-3540 seconds (¬±15%)</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::isAvailable()</div>
                        <div class="method-signature">SmartCache::isAvailable(): bool</div>
                        <p>Check if cache backend is available (circuit breaker).</p>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> bool - True if cache is available
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">if (SmartCache::isAvailable()) {
    $data = SmartCache::get('key');
} else {
    $data = $this->fallbackSource();
}</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::withFallback()</div>
                        <div class="method-signature">SmartCache::withFallback(callable $operation, callable $fallback): mixed</div>
                        <p>Execute cache operation with automatic fallback on failure.</p>
                        <div class="parameter">
                            <span class="parameter-name">$operation</span> <span class="parameter-type">(callable)</span> - Primary cache operation
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$fallback</span> <span class="parameter-type">(callable)</span> - Fallback if cache fails
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> mixed - Result from operation or fallback
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">$data = SmartCache::withFallback(
    fn() => SmartCache::get('key'),
    fn() => $this->database->get('key')
);</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::throttle()</div>
                        <div class="method-signature">SmartCache::throttle(string $key, int $maxAttempts, int $decaySeconds, callable $callback): mixed</div>
                        <p>Rate-limit cache regeneration to prevent stampede.</p>
                        <div class="parameter">
                            <span class="parameter-name">$key</span> <span class="parameter-type">(string)</span> - Cache key
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$maxAttempts</span> <span class="parameter-type">(int)</span> - Max regenerations allowed
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$decaySeconds</span> <span class="parameter-type">(int)</span> - Time window in seconds
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$callback</span> <span class="parameter-type">(callable)</span> - Value generator
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> mixed - Cached or generated value
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">$data = SmartCache::throttle('expensive_key', 10, 60, function() {
    return expensiveOperation();
}); // Max 10 regenerations per 60 seconds</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::rememberWithStampedeProtection()</div>
                        <div class="method-signature">SmartCache::rememberWithStampedeProtection(string $key, int $ttl, callable $callback, float $beta = 1.0): mixed</div>
                        <p>Remember with XFetch algorithm for probabilistic early refresh.</p>
                        <div class="parameter">
                            <span class="parameter-name">$key</span> <span class="parameter-type">(string)</span> - Cache key
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$ttl</span> <span class="parameter-type">(int)</span> - Time to live in seconds
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$callback</span> <span class="parameter-type">(callable)</span> - Value generator
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$beta</span> <span class="parameter-type">(float)</span> - Beta factor (higher = earlier refresh)
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> mixed - Cached or generated value
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">$data = SmartCache::rememberWithStampedeProtection(
    'popular_key', 3600, fn() => expensiveQuery(), 1.0
);</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::getCircuitBreakerStats()</div>
                        <div class="method-signature">SmartCache::getCircuitBreakerStats(): array</div>
                        <p>Get circuit breaker statistics.</p>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> array - Stats (state, failures, successes, last_failure_time)
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">$stats = SmartCache::getCircuitBreakerStats();
// Returns: ['state' => 'closed', 'failures' => 0, 'successes' => 5]</code></pre>
                        </div>
                    </div>

                    <h2 id="cost-aware-api">üß† Cost-Aware Caching API</h2>

                    <div class="method">
                        <div class="method-name">SmartCache::cacheValue()</div>
                        <div class="method-signature">SmartCache::cacheValue(string $key): ?array</div>
                        <p>Get value score metadata for a specific cache key.</p>
                        <div class="parameter">
                            <span class="parameter-name">$key</span> <span class="parameter-type">(string)</span> - Cache key to inspect
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> ?array - Metadata (cost_ms, access_count, size_bytes, score, last_accessed) or null
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">$meta = SmartCache::cacheValue('analytics');
// ['cost_ms' => 800, 'access_count' => 47, 'size_bytes' => 4096, 'score' => 92.4, ...]</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::getCacheValueReport()</div>
                        <div class="method-signature">SmartCache::getCacheValueReport(): array</div>
                        <p>Get a full report of all tracked cache entries sorted by value score (highest first).</p>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> array - List of all tracked keys with their metadata and scores
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">$report = SmartCache::getCacheValueReport();
// [
//   ['key' => 'analytics', 'cost_ms' => 800, 'access_count' => 47, 'score' => 92.4],
//   ['key' => 'users',     'cost_ms' => 5,   'access_count' => 120, 'score' => 14.1],
// ]</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::suggestEvictions()</div>
                        <div class="method-signature">SmartCache::suggestEvictions(int $count = 10): array</div>
                        <p>Suggest the lowest-value cache entries for eviction when you need to free space.</p>
                        <div class="parameter">
                            <span class="parameter-name">$count</span> <span class="parameter-type">(int)</span> - Number of eviction candidates to return (default: 10)
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> array - List of lowest-score keys with metadata
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">$evictable = SmartCache::suggestEvictions(5);
// Returns the 5 lowest-score keys ‚Äî safest to remove first
foreach ($evictable as $entry) {
    SmartCache::forget($entry['key']);
}</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::getCostAwareManager()</div>
                        <div class="method-signature">SmartCache::getCostAwareManager(): ?\SmartCache\Services\CostAwareCacheManager</div>
                        <p>Get the underlying CostAwareCacheManager instance for advanced usage.</p>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> ?CostAwareCacheManager - Manager instance or null if disabled
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">$manager = SmartCache::getCostAwareManager();
if ($manager) {
    echo "Tracking " . $manager->trackedKeyCount() . " keys";
}</code></pre>
                        </div>
                    </div>

                    <h2 id="management-api">üõ†Ô∏è Cache Management</h2>

                    <div class="method">
                        <div class="method-name">SmartCache::clear()</div>
                        <div class="method-signature">SmartCache::clear(): bool</div>
                        <p>Clear all cache keys managed by SmartCache (tracked keys only).</p>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> bool - True on success
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">SmartCache::clear(); // Clear all SmartCache managed keys</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::flush()</div>
                        <div class="method-signature">SmartCache::flush(): bool</div>
                        <p>Flush the entire cache store (all keys, not just SmartCache-managed ones). Equivalent to Laravel's <code>Cache::flush()</code>.</p>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> bool - True on success
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">SmartCache::flush(); // Flush ALL cache keys (entire store)</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::getRaw()</div>
                        <div class="method-signature">SmartCache::getRaw(string $key): mixed</div>
                        <p>Get the raw (unrestored) value from cache, bypassing optimization strategies. Useful for diagnostics and debugging.</p>
                        <div class="parameter">
                            <span class="parameter-name">$key</span> <span class="parameter-type">(string)</span> - Cache key
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> mixed - Raw cached value (may include optimization markers)
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">$raw = SmartCache::getRaw('users');
// Returns the raw stored value with compression/chunking markers intact</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">SmartCache::getManagedKeys()</div>
                        <div class="method-signature">SmartCache::getManagedKeys(): array</div>
                        <p>Get all keys currently managed by SmartCache.</p>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> array - List of managed cache keys
                        </div>
                        <div class="example">
                            <strong>Example:</strong>
                            <pre><code class="language-php">$keys = SmartCache::getManagedKeys();
foreach ($keys as $key) {
    echo "Managed key: {$key}\n";
}</code></pre>
                        </div>
                    </div>

                    <h2 id="helpers-api">üîß Helper Functions</h2>

                    <div class="method">
                        <div class="method-name">smart_cache()</div>
                        <div class="method-signature">smart_cache(string|array|null $key = null, mixed $value = null, DateTimeInterface|DateInterval|int|null $ttl = null): mixed</div>
                        <p>Global helper function for SmartCache operations.</p>
                        <div class="parameter">
                            <span class="parameter-name">$key</span> <span class="parameter-type">(string|array|null)</span> - Cache key or key-value array
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$value</span> <span class="parameter-type">(mixed)</span> - Value to store
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">$ttl</span> <span class="parameter-type">(DateTimeInterface|DateInterval|int|null)</span> - Time to live
                        </div>
                        <div class="parameter">
                            <span class="return-type">Returns:</span> mixed - SmartCache instance or cached value
                        </div>
                        <div class="example">
                            <strong>Examples:</strong>
                            <pre><code class="language-php">// Get SmartCache instance
$cache = smart_cache();

// Get value
$users = smart_cache('users');

// Set value
smart_cache('users', $users, 3600);</code></pre>
                        </div>
                    </div>

                    <h2 id="cli-api">üíª CLI Commands</h2>

                    <div class="method">
                        <div class="method-name">smart-cache:status</div>
                        <div class="method-signature">php artisan smart-cache:status [--force]</div>
                        <p>Display comprehensive information about SmartCache usage, configuration, and performance.</p>
                        <div class="parameter">
                            <span class="parameter-name">--force</span> <span class="parameter-type">(flag)</span> - Include Laravel cache analysis and detailed diagnostics
                        </div>
                        <div class="example">
                            <strong>Examples:</strong>
                            <pre><code class="language-bash"># Basic status overview
php artisan smart-cache:status

# Detailed analysis with recommendations
php artisan smart-cache:status --force</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">smart-cache:clear</div>
                        <div class="method-signature">php artisan smart-cache:clear [key] [--force]</div>
                        <p>Clear SmartCache managed items. Optionally specify a key to clear only that item.</p>
                        <div class="parameter">
                            <span class="parameter-name">key</span> <span class="parameter-type">(optional)</span> - Specific cache key to clear
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">--force</span> <span class="parameter-type">(flag)</span> - Force clear keys even if not managed by SmartCache
                        </div>
                        <div class="example">
                            <strong>Examples:</strong>
                            <pre><code class="language-bash"># Clear all SmartCache managed keys
php artisan smart-cache:clear

# Clear specific key
php artisan smart-cache:clear user_profile_123

# Force clear any cache key
php artisan smart-cache:clear --force</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">smart-cache:warm</div>
                        <div class="method-signature">php artisan smart-cache:warm [--keys=]</div>
                        <p>Pre-populate cache with frequently accessed data using registered warmers.</p>
                        <div class="parameter">
                            <span class="parameter-name">--keys</span> <span class="parameter-type">(optional)</span> - Comma-separated list of specific keys to warm
                        </div>
                        <div class="example">
                            <strong>Examples:</strong>
                            <pre><code class="language-bash"># Warm all registered cache warmers
php artisan smart-cache:warm

# Warm specific keys only
php artisan smart-cache:warm --keys=products,categories</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <div class="method-name">smart-cache:cleanup-chunks</div>
                        <div class="method-signature">php artisan smart-cache:cleanup-chunks</div>
                        <p>Clean up orphaned chunks from expired or deleted chunked cache entries.</p>
                        <div class="example">
                            <strong>Examples:</strong>
                            <pre><code class="language-bash"># Run cleanup manually
php artisan smart-cache:cleanup-chunks

# Schedule in Kernel.php
$schedule->command('smart-cache:cleanup-chunks')->daily();</code></pre>
                        </div>
                    </div>

                    <div class="alert alert-info">
                        All methods match Laravel's Cache facade API. Optimizations (compression, chunking, invalidation) are applied transparently based on data size and type.
                    </div>
                </div>

                <!-- Testing & Validation Tab -->
                <div id="testing" class="tab-container">
                    <h1>üß™ Testing & Validation</h1>
                    
                    <div class="alert alert-info">
                        A sample test controller you can drop into your application to validate SmartCache features end-to-end.
                    </div>

                    <h2>Test Controller</h2>
                    <p>The controller below exercises core SmartCache features ‚Äî basic operations, compression, chunking, SWR patterns, invalidation, and monitoring ‚Äî and returns structured JSON results.</p>

                    <h3>Controller Implementation</h3>

                    <pre><code class="language-php">
namespace App\Http\Controllers\Api\V1;

use App\Http\Controllers\Controller;
use SmartCache\Facades\SmartCache;

class TestSmartCacheDirectlyController extends Controller
{
    public function testSmartCacheFeatures()
    {
        $packageInfo = ['version' => '1.4.2', 'features_tested' => 20];
        $tests = [];

        try {
            // Test 1: Basic Operations
            $tests['basic_operations'] = $this->testBasicOperations();
            
            // Test 2: Compression (2000+ records)
            $tests['compression_test'] = $this->testCompressionFeature();
            
            // Test 3: Chunking (5000+ items)
            $tests['chunking_test'] = $this->testChunkingFeature();
            
            // Test 4: Helper Functions
            $tests['helper_function'] = $this->testHelperFunctions();
            
            // Test 5: SWR Patterns (Laravel 12+)
            if (version_compare(app()->version(), '12.0', '>=')) {
                $tests['swr_patterns'] = $this->testSWRPatterns();
            }
            
            // Test 6: Cache Invalidation & Tags
            $tests['cache_invalidation'] = $this->testCacheInvalidation();
            
            // Test 7: Performance Monitoring
            $tests['performance_monitoring'] = $this->testPerformanceMonitoring();
            
            // Test 8: Advanced Features (remember, locking)
            $tests['advanced_features'] = $this->testAdvancedFeatures();

            return response()->json([
                'message' => 'SmartCache feature tests completed',
                'package_info' => $packageInfo,
                'tests' => $tests,
                'overall_status' => 'success'
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'message' => 'SmartCache test failed',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    private function testBasicOperations()
    {
        $testData = ['data' => 'test_value', 'number' => 123, 'array' => range(1, 10)];

        // Test facade operations
        SmartCache::put('test_facade', $testData, 300);
        $facadeResult = SmartCache::get('test_facade');
        
        // Test helper operations  
        smart_cache(['test_helper' => $testData], 300);
        $helperResult = smart_cache('test_helper');

        return [
            'status' => 'success',
            'facade_results' => [
                'data_integrity' => $testData === $facadeResult,
                'has_key' => SmartCache::has('test_facade')
            ],
            'helper_results' => [
                'data_integrity' => $testData === $helperResult,
                'has_key' => SmartCache::has('test_helper')
            ],
            'both_methods_working' => ($testData === $facadeResult && $testData === $helperResult)
        ];
    }

    // ... Additional test methods for compression, chunking, SWR patterns, etc.
    // See complete implementation in the GitHub Gist
}</code></pre>

                    <div class="alert alert-info">
                        <strong>üìã Complete Implementation:</strong> The full controller code with all test methods, detailed validation logic, and comprehensive error handling is available in the <a href="https://gist.github.com/iazaran/d0706e21db6a445c1e9a63de7fcbb2ad" target="_blank">GitHub Gist</a>.
                    </div>

                    <h2>How to Use the Test Controller</h2>
                    
                    <h3>1. Installation</h3>
                    <p>Add this controller to your Laravel application:</p>
                    
                    <div class="step">
                        <span class="step-number">1</span>
                        <strong>Create the controller:</strong>
                        <pre><code class="language-bash">php artisan make:controller Api/V1/TestSmartCacheDirectlyController</code></pre>
                    </div>

                    <div class="step">
                        <span class="step-number">2</span>
                        <strong>Copy the implementation above into your controller</strong>
                    </div>

                    <div class="step">
                        <span class="step-number">3</span>
                        <strong>Add a route in your <span class="code-inline">routes/api.php</span>:</strong>
                        <pre><code class="language-php">Route::get('/test-smart-cache', [TestSmartCacheDirectlyController::class, 'testSmartCacheFeatures']);</code></pre>
                    </div>

                    <h3>2. Running the Tests</h3>
                    <p>Access the endpoint to run comprehensive tests:</p>
                    
                    <pre><code class="language-bash"># Via HTTP request
curl http://your-app.com/api/test-smart-cache

# Or via browser
http://your-app.com/api/test-smart-cache</code></pre>

                    <h3>3. Understanding the Results</h3>
                    <p>The test controller returns a comprehensive JSON response with detailed results:</p>

                    <pre><code class="language-json">{
  "message": "SmartCache feature tests completed",
  "package_info": {
    "version": "1.4.2",
    "features_tested": 20
  },
  "tests": {
    "basic_operations": {
      "status": "success",
      "both_methods_working": true,
      "facade_results": { "data_integrity": true, "has_key": true },
      "helper_results": { "data_integrity": true, "has_key": true }
    },
    "compression_test": {
      "status": "success",
      "original_count": 2000,
      "estimated_size_kb": 2207.29,
      "both_methods_successful": true
    },
    "chunking_test": {
      "status": "success", 
      "original_count": 5000,
      "data_matches": true
    },
    "performance_monitoring": {
      "status": "success",
      "monitoring_working": true
    }
    // ... additional test results
  },
  "overall_status": "success"
}</code></pre>

                    <div class="alert alert-info">
                        <strong>üìä Complete Response:</strong> The full JSON response includes detailed metrics for all 20+ features, performance timings, and comprehensive validation results. View the complete response format in the <a href="https://gist.github.com/iazaran/d0706e21db6a445c1e9a63de7fcbb2ad" target="_blank">GitHub Gist</a>.
                    </div>

                    <h2>What Each Test Validates</h2>
                    
                    <div class="feature-grid">
                        <div class="feature-card">
                            <h4>üîß Basic Operations</h4>
                            <p>Tests put/get/has/forget operations with both facade and helper functions, ensuring data integrity and method compatibility.</p>
                        </div>
                        
                        <div class="feature-card">
                            <h4>üì¶ Compression Testing</h4>
                            <p>Validates automatic compression with 2000+ records, measuring size reduction and performance impact.</p>
                        </div>
                        
                        <div class="feature-card">
                            <h4>üß© Chunking Validation</h4>
                            <p>Tests chunking strategy with 5000+ items, verifying data integrity and retrieval performance.</p>
                        </div>
                        
                        <div class="feature-card">
                            <h4>üåä SWR Patterns</h4>
                            <p>Validates Stale-While-Revalidate patterns, write-through, write-behind, and cache-aside strategies.</p>
                        </div>
                        
                        <div class="feature-card">
                            <h4>üîó Cache Invalidation</h4>
                            <p>Tests tag-based invalidation, pattern matching, and dependency tracking features.</p>
                        </div>
                        
                        <div class="feature-card">
                            <h4>üìä Performance Monitoring</h4>
                            <p>Validates metrics collection, performance analysis, and automated recommendations.</p>
                        </div>
                    </div>

                    <div class="alert alert-success">
                        <strong>Tip:</strong> Run this controller in staging before deploying to production. It validates data integrity and surfaces any configuration issues early.
                    </div>

                    <p>Full controller source: <a href="https://gist.github.com/iazaran/d0706e21db6a445c1e9a63de7fcbb2ad" target="_blank">GitHub Gist</a></p>
                </div>

                <!-- Migration Tab -->
                <div id="migration" class="tab-container">
                    <h1>üîÑ Migration Guide</h1>
                    
                    <h2>From Laravel Cache</h2>
                    <p>SmartCache implements the same <code>Repository</code> contract as Laravel's Cache facade. Migration requires one import change:</p>

                    <div class="step">
                        <span class="step-number">1</span>
                        <strong>Install SmartCache:</strong>
                        <pre><code class="language-bash">composer require iazaran/smart-cache</code></pre>
                    </div>

                    <div class="step">
                        <span class="step-number">2</span>
                        <strong>Update your imports:</strong>
                        <pre><code class="language-php">// Before
use Illuminate\Support\Facades\Cache;

// After
use SmartCache\Facades\SmartCache;</code></pre>
                    </div>

                    <div class="step">
                        <span class="step-number">3</span>
                        <strong>Update your code:</strong>
                        <pre><code class="language-php">// Before
Cache::put('key', $value, 3600);
$value = Cache::get('key');

// SmartCache (works exactly the same, with automatic optimizations)
SmartCache::put('key', $value, 3600);
$value = SmartCache::get('key');</code></pre>
                    </div>

                    <div class="alert alert-success">
                        Your existing code works unchanged, with automatic optimizations applied transparently.
                    </div>

                    <h2>Gradual Migration</h2>
                    <p>You can migrate gradually by using both facades:</p>

                    <pre><code class="language-php">use Illuminate\Support\Facades\Cache;
use SmartCache\Facades\SmartCache;

// Keep existing code unchanged
Cache::put('old_key', $value, 3600);

// Use SmartCache for optimized caching
SmartCache::put('optimized_key', $value, 3600);
SmartCache::swr('api_data', $callback, 300, 900);</code></pre>

                    <h2>Testing Migration</h2>
                    <p>Test your migration with these commands:</p>

                    <pre><code class="language-bash"># Test basic functionality
php artisan smart-cache:status

# Test with your application
php artisan tinker
>>> SmartCache::put('test', 'Hello World', 60);
>>> SmartCache::get('test');
=> "Hello World"</code></pre>

                    <h2>Rollback Plan</h2>
                    <p>If you need to rollback, simply change the imports back:</p>

                    <pre><code class="language-bash"># Change back to Laravel Cache imports in your code
# Then remove SmartCache package
composer remove iazaran/smart-cache</code></pre>

                    <div class="alert alert-warning">
                        <strong>Note:</strong> Rolling back will lose SmartCache-specific optimizations, but your data will remain accessible through Laravel's standard cache methods.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Tab functionality
        document.addEventListener('DOMContentLoaded', function() {
            const tabButtons = document.querySelectorAll('.tab-nav button');
            const tabContainers = document.querySelectorAll('.tab-container');
            const navLinks = document.querySelectorAll('.nav-link');

            function showTab(tabId) {
                // Hide all tabs
                tabContainers.forEach(tab => {
                    tab.classList.remove('active');
                });

                // Remove active class from all buttons
                tabButtons.forEach(btn => {
                    btn.classList.remove('active');
                });

                // Remove active class from all nav links
                navLinks.forEach(link => {
                    link.classList.remove('active');
                });

                // Show selected tab
                const selectedTab = document.getElementById(tabId);
                if (selectedTab) {
                    selectedTab.classList.add('active');
                }

                // Add active class to corresponding nav link
                const activeNavLink = document.querySelector(`[data-tab="${tabId}"]`);
                if (activeNavLink) {
                    activeNavLink.classList.add('active');
                }

                // Scroll to top of content
                const content = document.querySelector('.content');
                if (content) {
                    content.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }

            // Tab button clicks
            tabButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const tabId = this.getAttribute('data-tab');
                    showTab(tabId);
                });
            });

            // Nav link clicks
            navLinks.forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    const tabId = this.getAttribute('data-tab');
                    showTab(tabId);
                });
            });

            // Handle URL hash
            if (window.location.hash) {
                const tabId = window.location.hash.substring(1);
                showTab(tabId);
            }

            // Update URL when switching tabs
            tabButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const tabId = this.getAttribute('data-tab');
                    window.history.pushState(null, null, '#' + tabId);
                });
            });

            // Handle browser back/forward
            window.addEventListener('popstate', function() {
                if (window.location.hash) {
                    const tabId = window.location.hash.substring(1);
                    showTab(tabId);
                }
            });
        });
    </script>
</body>
</html>